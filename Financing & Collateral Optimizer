# services/optimizer/financing_optimizer.py
"""
Financing optimizer: given positions and available financing offers,
allocate financing to positions to minimize financing cost subject to constraints.
This implementation uses CVXPY (convex relaxation). In production, discrete choices are handled
by a MILP solver (Gurobi, CPLEX) or hybrid heuristics.
"""
from typing import List, Dict, Tuple
import numpy as np
import cvxpy as cp
from core.models import Position, FinancingOffer
import uuid
from datetime import datetime
import logging
logger = logging.getLogger(__name__)

def build_input_matrix(positions: List[Position], offers: List[FinancingOffer]):
    # Build per-instrument matching matrix
    m = len(positions)
    n = len(offers)
    notional = np.array([p.notional for p in positions])  # m
    rates = np.array([o.rate for o in offers])  # n
    # matching matrix: pos_i can be financed by offer_j if instrument matches or collateral acceptable.
    M = np.zeros((m, n))
    for i, p in enumerate(positions):
        for j, o in enumerate(offers):
            if p.instrument_id == o.instrument_id or o.collateral_type is None:
                M[i, j] = 1.0
    return notional, rates, M

def optimize_financing(positions: List[Position], offers: List[FinancingOffer], max_alloc_per_offer: Dict[str, float]=None) -> Dict:
    if max_alloc_per_offer is None:
        max_alloc_per_offer = {o.offer_id: 1e12 for o in offers}

    notional, rates, M = build_input_matrix(positions, offers)
    m, n = M.shape
    # decision: x[i,j] fraction (0..1) of position i financed by offer j
    x = cp.Variable((m, n))
    # objective: minimize sum_j rate_j * sum_i notional_i * x_ij
    rate_vec = rates.reshape((1, n))
    cost = cp.sum(cp.multiply(cp.matmul(notional.reshape((m,1)), rate_vec), x))
    # constraints:
    constraints = []
    # cover all positions: sum_j x_ij == 1 for each i (fully financed)
    constraints.append(cp.sum(x, axis=1) == 1)
    # matching constraints: x_ij <= M_ij
    constraints.append(x <= M)
    constraints.append(x >= 0)
    # per-offer capacity: sum_i notional_i * x_ij <= limit_j
    limit_vec = np.array([max_alloc_per_offer[o.offer_id] for o in offers])
    constraints.append(cp.matmul(notional.reshape((1,m)), x).reshape((n,)) <= limit_vec)
    # solve
    prob = cp.Problem(cp.Minimize(cost), constraints)
    prob.solve(solver=cp.OSQP, verbose=False)
    if prob.status not in ["optimal", "optimal_inaccurate"]:
        logger.error("Solver failed with status %s", prob.status)
        # fallback: naive allocation
        return {"status": "failed", "reason": prob.status}
    x_val = x.value
    # format result
    allocations = []
    for i, p in enumerate(positions):
        for j, o in enumerate(offers):
            frac = float(x_val[i, j])
            if frac > 1e-6:
                allocations.append({
                    "position_id": p.position_id,
                    "offer_id": o.offer_id,
                    "allocated_notional": float(frac * p.notional),
                    "rate": o.rate
                })
    return {
        "status": "ok",
        "run_id": str(uuid.uuid4()),
        "created_at": datetime.utcnow().isoformat(),
        "allocations": allocations,
        "objective_value": float(prob.value)
    }
