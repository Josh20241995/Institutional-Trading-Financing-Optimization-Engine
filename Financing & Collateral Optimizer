# services/normalization/normalizer.py
from core.models import Position
from datetime import datetime
from typing import Dict, Any
import logging
logger = logging.getLogger(__name__)

# A small canonicalizer example. In production, this would call a canonical ID service, currency conversion, etc.
def normalize_position(raw: Dict[str, Any]) -> Position:
    # Validate required fields
    try:
        pos = Position(
            position_id = raw.get("position_id"),
            account_id = raw.get("account_id"),
            instrument_id = raw.get("instrument_id") or raw.get("isin") or raw.get("figi"),
            asset_type = raw.get("asset_type"),
            quantity = float(raw.get("quantity", 0.0)),
            notional = float(raw.get("quantity", 0.0)) * float(raw.get("price", 0.0)),
            side = raw.get("side", "long"),
            valuation = float(raw.get("price", 0.0)),
            currency = raw.get("currency", "USD"),
            timestamp = raw.get("timestamp", datetime.utcnow())
        )
    except Exception as exc:
        logger.exception("Invalid position payload")
        raise
    return pos


# services/optimizer/financing_optimizer.py
"""
Financing optimizer: given positions and available financing offers,
allocate financing to positions to minimize financing cost subject to constraints.
This implementation uses CVXPY (convex relaxation). In production, discrete choices are handled
by a MILP solver (Gurobi, CPLEX) or hybrid heuristics.
"""
from typing import List, Dict, Tuple
import numpy as np
import cvxpy as cp
from core.models import Position, FinancingOffer
import uuid
from datetime import datetime
import logging
logger = logging.getLogger(__name__)

def build_input_matrix(positions: List[Position], offers: List[FinancingOffer]):
    # Build per-instrument matching matrix
    m = len(positions)
    n = len(offers)
    notional = np.array([p.notional for p in positions])  # m
    rates = np.array([o.rate for o in offers])  # n
    # matching matrix: pos_i can be financed by offer_j if instrument matches or collateral acceptable.
    M = np.zeros((m, n))
    for i, p in enumerate(positions):
        for j, o in enumerate(offers):
            if p.instrument_id == o.instrument_id or o.collateral_type is None:
                M[i, j] = 1.0
    return notional, rates, M

def optimize_financing(positions: List[Position], offers: List[FinancingOffer], max_alloc_per_offer: Dict[str, float]=None) -> Dict:
    if max_alloc_per_offer is None:
        max_alloc_per_offer = {o.offer_id: 1e12 for o in offers}

    notional, rates, M = build_input_matrix(positions, offers)
    m, n = M.shape
    # decision: x[i,j] fraction (0..1) of position i financed by offer j
    x = cp.Variable((m, n))
    # objective: minimize sum_j rate_j * sum_i notional_i * x_ij
    rate_vec = rates.reshape((1, n))
    cost = cp.sum(cp.multiply(cp.matmul(notional.reshape((m,1)), rate_vec), x))
    # constraints:
    constraints = []
    # cover all positions: sum_j x_ij == 1 for each i (fully financed)
    constraints.append(cp.sum(x, axis=1) == 1)
    # matching constraints: x_ij <= M_ij
    constraints.append(x <= M)
    constraints.append(x >= 0)
    # per-offer capacity: sum_i notional_i * x_ij <= limit_j
    limit_vec = np.array([max_alloc_per_offer[o.offer_id] for o in offers])
    constraints.append(cp.matmul(notional.reshape((1,m)), x).reshape((n,)) <= limit_vec)
    # solve
    prob = cp.Problem(cp.Minimize(cost), constraints)
    prob.solve(solver=cp.OSQP, verbose=False)
    if prob.status not in ["optimal", "optimal_inaccurate"]:
        logger.error("Solver failed with status %s", prob.status)
        # fallback: naive allocation
        return {"status": "failed", "reason": prob.status}
    x_val = x.value
    # format result
    allocations = []
    for i, p in enumerate(positions):
        for j, o in enumerate(offers):
            frac = float(x_val[i, j])
            if frac > 1e-6:
                allocations.append({
                    "position_id": p.position_id,
                    "offer_id": o.offer_id,
                    "allocated_notional": float(frac * p.notional),
                    "rate": o.rate
                })
    return {
        "status": "ok",
        "run_id": str(uuid.uuid4()),
        "created_at": datetime.utcnow().isoformat(),
        "allocations": allocations,
        "objective_value": float(prob.value)
    }



# services/decision_engine/decision_service.py
from core.models import Recommendation
from datetime import datetime
import uuid
import logging
logger = logging.getLogger(__name__)

def score_allocation(allocation_item: dict, baseline_rate: float, rwa_impact: float) -> float:
    # simplistic score: savings in basis points weighted by RWA improvement
    saving = baseline_rate - allocation_item["rate"]
    score = saving * 10000 - 0.5 * rwa_impact
    # normalize roughly into 0..1 later
    return float(score)

def generate_recommendations(optimizer_result: dict, baseline_rate_lookup: dict, rwa_lookup: dict, run_id: str):
    recs = []
    for allocation in optimizer_result.get("allocations", []):
        pos_id = allocation["position_id"]
        baseline = baseline_rate_lookup.get(pos_id, allocation["rate"])
        rwa_delta = rwa_lookup.get(pos_id, 0.0)
        score = score_allocation(allocation, baseline, rwa_delta)
        confidence = min(1.0, max(0.0, (score + 100)/200))  # quick mapping to 0..1
        rec = Recommendation(
            rec_id=str(uuid.uuid4()),
            run_id=run_id,
            created_at=datetime.utcnow(),
            type="refinance",
            description=f"Refinance pos {pos_id} via offer {allocation['offer_id']} at rate {allocation['rate']:.6f}",
            actions=[{
                "action": "post_financing_order",
                "position_id": pos_id,
                "offer_id": allocation["offer_id"],
                "notional": allocation["allocated_notional"]
            }],
            expected_pnl = (baseline - allocation["rate"]) * allocation["allocated_notional"],
            expected_rwa_delta = rwa_delta,
            confidence = confidence,
            provenance = {
                "optimizer_objective": optimizer_result.get("objective_value"),
                "allocation": allocation
            }
        )
        recs.append(rec)
    # rank by confidence / expected_pnl
    recs = sorted(recs, key=lambda r: (r.confidence, r.expected_pnl), reverse=True)
    logger.info("Generated %d recommendations", len(recs))
    return recs


# services/api/main.py
from fastapi import FastAPI, HTTPException
from typing import List
from core.logging_cfg import logger
from core.models import Recommendation, Position, FinancingOffer
from services.normalization.normalizer import normalize_position
from services.optimizer.financing_optimizer import optimize_financing
from services.decision_engine.decision_service import generate_recommendations
from core.config import cfg
import uvicorn
import json
from datetime import datetime

app = FastAPI(title="Institutional Trading Optimization Engine API")

# In-memory simple stores for example. Replace with Kafka/DB in real system.
POSITIONS = []
OFFERS = []

@app.post("/ingest/position")
def ingest_position(payload: dict):
    p = normalize_position(payload)
    POSITIONS.append(p)
    logger.info("Ingested position", position_id=p.position_id)
    return {"status":"ok", "position_id": p.position_id}

@app.post("/ingest/offer")
def ingest_offer(payload: dict):
    o = FinancingOffer(**payload)
    OFFERS.append(o)
    logger.info("Ingested financing offer", offer_id=o.offer_id)
    return {"status":"ok", "offer_id": o.offer_id}

@app.post("/run/optimize")
def run_optimize():
    if not POSITIONS or not OFFERS:
        raise HTTPException(status_code=400, detail="Need positions and offers")
    # Run optimizer
    result = optimize_financing(POSITIONS, OFFERS)
    if result["status"] != "ok":
        raise HTTPException(status_code=500, detail=result.get("reason"))
    # Baseline & rwa lookups are placeholders
    baseline_lookup = {p.position_id: 0.02 for p in POSITIONS}
    rwa_lookup = {p.position_id: 0.0 for p in POSITIONS}
    recs = generate_recommendations(result, baseline_lookup, rwa_lookup, run_id=cfg.run_id)
    # For demo: persist recs to file (audit)
    with open(f"artifacts/recommendations_{datetime.utcnow().isoformat()}.json", "w") as fh:
        fh.write(json.dumps([r.dict() for r in recs], default=str, indent=2))
    return {"status":"ok", "recommendations": [r.dict() for r in recs]}

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8080)



